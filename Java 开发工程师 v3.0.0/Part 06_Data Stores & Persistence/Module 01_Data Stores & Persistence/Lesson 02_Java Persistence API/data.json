{
  "data": {
    "lesson": {
      "id": 900018,
      "key": "3207f045-58e3-4fd1-91ac-ed65ef243510",
      "title": "Java Persistence API",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Learn how to write simple, maintainable and flexible persistence layer code using JPA and Spring Data JPA.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/3207f045-58e3-4fd1-91ac-ed65ef243510/900018/1564509538748/Java+Persistence+API+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/3207f045-58e3-4fd1-91ac-ed65ef243510/900018/1564509535590/Java+Persistence+API+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 900011,
          "key": "caef308a-df87-4771-8ee7-bca8862222e7",
          "title": "Object Relational Mapping (ORM)",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "caef308a-df87-4771-8ee7-bca8862222e7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 899988,
              "key": "07470cf6-abb1-4698-9002-59295ae25afd",
              "title": "JavaND#305 C03 L02 A01 Object Relational Mapping (ORM)",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "z7g-hN4eBOU",
                "china_cdn_id": "z7g-hN4eBOU.mp4"
              }
            },
            {
              "id": 906667,
              "key": "8e214837-9f67-4519-bc62-bae6371c3157",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Resources\n---\n* [Hibernate](http://hibernate.org)\n* [Java Persistence API](https://docs.oracle.com/javaee/7/tutorial/persistence-intro.htm)",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 900013,
          "key": "321d70c2-3451-4051-ae31-5f4f1ed00cfe",
          "title": "Java Persistence API (JPA)",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "321d70c2-3451-4051-ae31-5f4f1ed00cfe",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 899982,
              "key": "ad1324c0-43e6-462c-a833-58fe6ac00ced",
              "title": "JavaND#305 C03 L02 A02 JPA Introduction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "uExqq5otEVQ",
                "china_cdn_id": "uExqq5otEVQ.mp4"
              }
            },
            {
              "id": 899981,
              "key": "102095d0-826a-4c3c-a075-42bfda38bc74",
              "title": "JPA Entities",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Entities\nAn entity is a plain old java class that typically represents a table in a relational database. Fields in the class map to columns of the table. An object of the entity class represents a row in the table. Field to column mappings and relations between entities are specified using JPA annotations.\n#### Entity Classes\nSince an entity class is instantiated and managed by the JPA provider, it needs to follow certain rules set forth by the JPA specification.\n\nIt must be marked with _javax.persistence.Entity_ annotation. \nIt must have a public no argument constructor. \nIt  can not be declared final. No fields and methods can be declared final. \nEntities may extend both entity and non-entity classes, and non-entity classes may extend entity classes.\nFields can be declared private, protected, or package-private and can be accessed class accessor and modifier methods. \n#### Persistent Fields\nAll fields not annotated with _javax.persistence.Transient_ or _transient_ are considered persistent fields and will be mapped to columns based on their name. \n#### Primary Keys \nJust like a relational database table is expected to have a primary key, an entity _must_ have one as well. An Order entity could have the order number as its primary key. Composite keys are supported too. The field that is the primary key must be annotated with _javax.persistence.Id_.  \n\nA detailed list of types that are supported as primary key types can be found in the [JPA specification](https://docs.oracle.com/cd/E19798-01/821-1841/bnbqf/index.html).\n#### Generated Identifiers\nPrimary key values can be automatically generated using the  [@GeneratedValue](https://docs.oracle.com/javaee/7/api/javax/persistence/GeneratedValue.html) annotation.\n\nIt supports four generation strategies, \nAUTO\nIDENTITY\nSEQUENCE\nTABLE\n\nIf a value is not specified for the _strategy_ field of the annotation, the default is AUTO.\n##### AUTO Generation\nThe database determines how to compute the value of this primary key. The value of the primary  key is unique at the database level. The database will use a sequence or a table based generator in case of numeric types. \n\nHere is an instance of how AUTO generation strategy can be used to map an entity primary key.\n\n \n```java\n@Entity\npublic class Order {\n \n    @Id\n    @GeneratedValue\n    private Long orderId;\n \n}\n```\nIn this case, the primary key values will be unique at the database level.\n##### IDENTITY Generation\nIf the primary key  is set as AUTO_INCREMENT in the table, this strategy can be used.\n\nTo use this generation type, we only need to set the _strategy_ parameter:\n\n```java\n@Entity\npublic class Order {\n \n    @Id\n    @GeneratedValue (strategy = GenerationType.IDENTITY)\n    private long orderId;\n \n}\n```\n##### SEQUENCE Generation\nThis generator uses sequences if supported by the database or switches to table generation if it doesn’t.\n\nLet’s use the @GenericGenerator annotation with SequenceStyleGenerator strategy as a way to play with the  sequence name.\n\n```java\n@Entity\npublic class Order {\n    @Id\n    @GeneratedValue(generator = \"sequence-generator\")\n    @GenericGenerator(\n      name = \"sequence-generator\",\n      strategy = \"org.hibernate.id.enhanced.SequenceStyleGenerator\",\n      parameters = {\n        @Parameter(name = \"sequence_name\", value = \"user_sequence\"),\n        @Parameter(name = \"initial_value\", value = \"4\"),\n        @Parameter(name = \"increment_size\", value = \"1\")\n        }\n    )\n    private Long orderId;\n     \n\n}\n```\nIn this example, an initial value is set for the sequence, which means the primary key generation will start at 4. **The generated values are unique per sequence.** If a sequence name is not specified, Hibernate will re-use the same *hibernate_sequence* for different types.\n##### TABLE Generation\nThe _TableGenerator_ uses an underlying database table that holds segments of identifier generation values.\nNext, the table needs to be customized. We are using the _@TableGenerator_ annotation method:\r\n```java\n@Entity\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.TABLE,\n      generator = \"table-generator\")\n    @TableGenerator(name = \"table-generator\",\n      table = \"dep_ids\",\n      pkColumnName = \"seq_id\",\n      valueColumnName = \"seq_value\")\n    private Long orderId;\n \n}\n```\nIn this example, we can see that other attributes such as the _pkColumnName_ and _valueColumnName_ can also be customized.\n\n**All of the four generation types will generate similar values but use different database mechanisms to do so.**",
              "instructor_notes": ""
            },
            {
              "id": 899992,
              "key": "14010292-0c5d-4d1d-b507-90a971cba490",
              "title": "JPA Quiz",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "14010292-0c5d-4d1d-b507-90a971cba490",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What are the requirements for a class to become an entity? Check all that apply.",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "The class must be annotated with the _javax.persistence.Entity_ annotation.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "The class must be marked final.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "Entities must not extend from other entity or non-entity classes.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk4",
                    "text": "The class must have a public or protected, no-argument constructor.",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 899987,
              "key": "3fc097e0-80e6-446a-bdd9-a721afb24fac",
              "title": "JPA Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "3fc097e0-80e6-446a-bdd9-a721afb24fac",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "How to exclude a field in the entity class from persistence?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "The field should not be annotated.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk2",
                    "text": "The field should be annotated with @Id.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "The field should be annotated with @Transient.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk4",
                    "text": "The field should not have a getter  & setter.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 899985,
              "key": "f775a0a5-c949-4449-bac3-fa9dfbdcbac7",
              "title": "JPA Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "f775a0a5-c949-4449-bac3-fa9dfbdcbac7",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the generation strategy to be used when the primary key is set to *AUTO_INCREMENT*?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "IDENTITY",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "SEQUENCE",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "AUTO_INC",
                    "is_correct": false
                  },
                  {
                    "id": "rbk4",
                    "text": "TABLE",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 899984,
              "key": "14cd1452-c9d3-433b-b24b-29c0b2336a6f",
              "title": "Javand305-C03-L02-A03-Entity-Relationships",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "l2S1JwcX8s4",
                "china_cdn_id": "l2S1JwcX8s4.mp4"
              }
            },
            {
              "id": 906788,
              "key": "92bc36eb-17db-49c0-b2ab-71f517dc4b8a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Entity Relationships\nRelationships are of the following types: one-to-one, one-to-many, many-to-one, and many-to-many. The following are commonly accepted definitions of these important concepts from the [Oracle website](https://docs.oracle.com/cd/E19798-01/821-1841/6nmq2cpai/index.html#indexterm-1028).\n\n**One-to-one:** Each entity is related to a single instance of another entity. A customer record in an ecommerce site would have a shipping address. If Customer and Address were modeled as entities, they would have a One-to-One relationship. One-to-one relationships are denoted by  [javax.persistence.OneToOne](https://docs.oracle.com/javaee/7/api/javax/persistence/OneToOne.html) annotation.\n\n**One-to-many:** An entity is  related to multiple instances of another entity. In the above example, it is common that a Customer has multiple(many) addresses, like a home and work address. In that case, the Customer and Address entities have a One-to-Many relationship. One-to-many relationships are denoted by  [javax.persistence.OneToMany](https://docs.oracle.com/javaee/7/api/javax/persistence/OneToMany.html) annotation.\n\n**Many-to-one:** Multiple instances of an entity can be related to a single instance of another entity. As the name says, its the inverse of One-to-Many.  In the example mentioned above, the relationship to Customer from the perspective of Address  is many-to-one. Many-to-one relationships are denoted using  [javax.persistence.ManyToOne](https://docs.oracle.com/javaee/7/api/javax/persistence/ManyToOne.html) annotation.\n\n**Many-to-many:** Multiple instances of one entity is related to multiple instances of another entity. For example, members of the same household can be Customer(s) of an ecommerce site and share the same Address. In this scenario, a Customer can have multiple(many) addresses and an Address could belong to multiple (many) Customer(s). Customer and Address have a Many-to-Many relationship. Many-to-many relationships are marked by [javax.persistence.ManyToMany](https://docs.oracle.com/javaee/7/api/javax/persistence/ManyToMany.html) annotation.\n#### Directed  Entity Relationships\nEntity relationship can be bi-directional or unidirectional. A bidirectional relationship has both an owning side and an inverse side. A unidirectional relationship has only an owning side. The owning side determines how the JPA  makes updates to the relationship in the database.\n##### Bidirectional Relationships\nIn a bidirectional relationship, both entities in the relationship refer to each other. . The relationship can be navigated  in both  directions.  \n\nBidirectional relationships must adhere to  these rules.\nThe inverse side must use _mappedBy_ field in the annotation to refer to the owning side of the relationship. \nIn a  many-to-one bidirectional relationship, the side of “many” the default owner and can not be changed. _mappedBy_ is unnecessary and must not be specified. \nFor one-to-one bidirectional relationships, the owning side is the side containing the foreign key..\nFor many-to-many bidirectional relationships, any side may be the owning side.\n##### Unidirectional Relationships\nAs the name suggests, only one entity has a relationship field that refers to the other. For example, _OrderItem_ contains  field that identifies _Product_, but _Product_ does not  have a field for _OrderItem_. In other words, _OrderItem_ knows about _Product_, but _Product_ doesn’t know which _OrderItem_ instances refer to it.\n",
              "instructor_notes": ""
            },
            {
              "id": 899990,
              "key": "0c3c9820-09c8-4d11-a929-18b04288201d",
              "title": "Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "0c3c9820-09c8-4d11-a929-18b04288201d",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "How to map a bi-directional One-to-Many relationship?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "One-to-Many and Many-to-one on both sides of the relationship with both of them including the foreign key marking the relationship.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk2",
                    "text": "One-to-Many relationship can not be bidirectional.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "One-to-Many and Many-to-one on both sides of the relationship. Owning side includes the foreign key and the inverse side includes the mappedBy field of the owning entity.",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 899991,
              "key": "09bf6708-ec06-4064-9a79-5280985abda0",
              "title": "Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "09bf6708-ec06-4064-9a79-5280985abda0",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Which of these statements is true for a Many-to-Many relationship?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "Many-to-Many can’t be a bidirectional relationship.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk2",
                    "text": "Many-to-Many requires a mapping table.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk3",
                    "text": "The inverse side of a Many-to-Many relationship is marked using _mappedBy_",
                    "is_correct": false
                  },
                  {
                    "id": "rbk4",
                    "text": "All of the above",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 899998,
              "key": "97d19345-dec6-440c-a599-f8b82a0c6fee",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "97d19345-dec6-440c-a599-f8b82a0c6fee",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Edited code to use `persist()` to persist rows in the table.",
                "Edited code to use `find()` to read rows from the table."
              ],
              "positive_feedback": "Nicely done.",
              "video_feedback": null,
              "description": "Provided here is [blank Starter Code that follows the instructor example](https://github.com/udacity/nd035-v1-C3-Data-Stores-and-Persistence/tree/master/exercises/c3_l2_exercise1) .\nStudents will write code using simple [EntityManager](https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html) methods persist() and find()."
            },
            {
              "id": 899989,
              "key": "530646db-2c06-48f8-a657-83cc2638c2a7",
              "title": "JavaND#305 C03 L02 A04 Cascade & Fetch",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "nl0BGMBtJ8E",
                "china_cdn_id": "nl0BGMBtJ8E.mp4"
              }
            },
            {
              "id": 899995,
              "key": "c60d192f-b360-482d-8502-66a75c54dc3a",
              "title": "Cascade Details",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Cascade Operations and Relationships\nEntities often depend on the existence of its related entities. In a relational database, a foreign key expects that a key of this value is present in the related table.  An order item  is part of an order, if the order is deleted, the order item has no meaning on its own and should also be deleted. In other words, a delete operation on _Order_ should “cascade” to the _OrderItem_. \n\nThe [javax.persistence.CascadeType](https://docs.oracle.com/javaee/7/api/javax/persistence/CascadeType.html) type is another attribute of relationship annotations that is used to define which operation on the owner should cascade to the related entity. \n\n**ALL:**  All operations on the owning entity will be applied to the related entity. _ALL_ specifies the following listed types. \n\n**DETACH:** Detaches the related entity when the owning entity is detached. \n\n**MERGE:** Merges the related entity when the owning entity is merged. \n\n**PERSIST:** Persists the related entity when the owning entity is persisted. \n\n**REFRESH:** Refreshes the related entity when the owning entity is refreshed. \n\n**REMOVE:** Removes the related entity when the owning entity is removed.\n\n\n\nHere’s an example: \n\n```java\n@OneToMany(cascade=REMOVE, mappedBy=\"customer\")\npublic Set<Order> getOrders() { return orders; }\n```\n#### Orphan Removal in Relationships\nIn a one-to-one or one-to-many relationship, it is often desirable to have the related entity deleted when it is removed from the relationship.  The _orphanRemoval_does just that. For example, if an order has many order items and one of them is removed from the order, the removed order item has no meaning without a parent and is considered an orphan. If _orphanRemoval_ is set to true, the orphaned order item entity will be deleted from the relational database.\n\nIn the example below, the _Order_ entity is deleted when its related “customer” entity is removed. \n\n```java\n@OneToMany(mappedBy=\"customer\", orphanRemoval=\"true\")\npublic List<Order> getOrders() { ... }\n```",
              "instructor_notes": ""
            },
            {
              "id": 899994,
              "key": "225eddaa-e595-49fd-88eb-8d72f0309d87",
              "title": "Fetch Details",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The _FetchType_ defines how and when JPA reads the related entities and it is one of the crucial elements for a fast persistence layer. \n\n#### FetchType.LAZY\nThe FetchType.LAZY tells JPA NOT to read the related entities when the root entity is read. The related entities are read lazily, meaning they are read when accessed. Typically, the related entities are loaded when their accessor (getter) method is called.   In the following example, OrderItem is NOT read along when  Order is read,\n\n```java\n@Entity\n@Table(name = \"orders\")\npublic class Order implements Serializable {\n  \n  @OneToMany(mappedBy = \"order\", fetch = FetchType.LAZY)\n  private Set<OrderItem> items = new HashSet<OrderItem>();\n  \n  \n}\n```\n#### FetchType.EAGER\nThe FetchType.EAGER tells JPA to read all the related entities when the root entity is read. As explained earlier, this is the default for one to many relationships, and you can see it in the following code snippets.\n\n\n\n```java\n@Entity\npublic class OrderItem implements Serializable\n{\n   @ManyToOne\n   private Product product;  \n}\n```\n\nWhen an OrderItem is fetched from the database, Hibernate will also fetch the related Product entity. JPA consistently fetches the Product entity and this does not have a consequence if you do not have a large number of one to many relationships. While it may make the query efficient, there is a drawback to it. If you have a large number of such relationships, it can slow the application as JPA is fetching additional entities. So be cognizant of this relationship!",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 900016,
          "key": "76812e3e-2cc6-43cb-bd89-c1980a02dbfa",
          "title": "JPA Querying Entities",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "76812e3e-2cc6-43cb-bd89-c1980a02dbfa",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 899993,
              "key": "45e1c5ba-783d-414d-986a-e99d4f09107d",
              "title": "Javand305-C03-L02-A05-Java-Persistence-Query-Language-Jpql 1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "N731xYU0HuA",
                "china_cdn_id": "N731xYU0HuA.mp4"
              }
            },
            {
              "id": 899996,
              "key": "60c26ff3-b215-4d30-adb1-712876f524cf",
              "title": "Query Syntax",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "JPQL is SQL like query language for querying/updating JPA entities. JPA translates JPQL to the SQL dialect of the underlying database that it connects to.\n\nThe JPQL feature set is extensive and is relatively simple to understand if one is familiar with SQL. It supports projection, filtering, sorting and grouping just like SQL does.\n\nA key difference between SQL and JPQL is that JPQL operates on entities not on tables. This difference is important to keep in mind when querying entity relationships. Hibernate, or any other JPA implementation, has to transform the JPQL query into SQL.\n\n## Entities and JPQL\nBelow is an example of how we might select a set of entities. Hibernate, or another JPA implementation, will map the entities to the appropriate locations in tables for us.\n\n### The SELECT clause\nThis part of the query is very different from SQL. When working in SQL, you work with columns in databases while in JPQL, you select a set of entities. Hibernate, as well as other JPA implementations, will find the entities in their corresponding tables and columns. \n\n```sql\nSELECT p FROM Patient p\n```\n\n### The FROM clause\nThe FROM clause determines which entities we will be selecting data from. Hibernate, as well as other JPA implementations, will find the entities in their corresponding tables. The JPQL FROM clause is similar to SQL, but will query entities rather than a table or column name.\n\nThe following code shows a JPQL query in which I select all Patient entities.\n\n```\nSELECT p FROM Patient p\n```\n\nIn this example, we reference the Patient entity instead of references the patient table. We assign the identification variable p to the Patient entity. The identification variable is similar to a variable in Java, and it is often called an “alias”. Similar to a new object in Java, we will use the identification variable, or alias, in all other parts of the query to reference this entity.\n\n### The WHERE clause\nAnother important JPQL query is the WHERE clause. The WHERE clause is used to filter out certain entities so we only have the ones needed for our use case. Please note, that while JPQL syntax is similar to SQL, it only supports a small subset of SQLfeatures. If you need more functionality, it may make sense for you to use an SQL query instead.\n\nThere are many comparison operators that we can use in JPQL. Most of them are identical to the comparison operators in SQL, and, just like in other languages, you can combine then with logical operators like AND, OR, and NOT. \n\nOperators for expressions with a single value:\n\nEqual To: `p.id = 10`\n\nNot Equal To: `p.id <> 10`\n\nSmaller Than: `p.id < 10`\n\nSmaller Than or Equal To: `p.id <= 10`\n\nGreater Than: `p.id > 10`\n\nGreater Than or Equal To: `p.id => 10`\n\nBetween: `p.id BETWEEN 5 and 10`\n\nLike: `p.firstName LIKE ‘%et%’`\rThe % character represents any character sequence. Here, we restrict the query to all patients with a firstName name that contains the string  This example restricts the query result to all Authors with a firstName that contains the String “et”, like Pete or Petra. You can use an _ instead of % as a single character wildcard. You can also negate the query with NOT to exclude all Patients with a matching firstName.\n\nIs null: `p.firstName IS NULL `\rTo find all Patients whose first names are not null, you can negate the query with NOT. As in, IS NOT NULL.\n\nIn: `p.firstName IN (‘Robby’, ‘Laura’)`\rRestricts the query result to all Patients with the first name Robby or Laura.\n \nOperators for expressions with a collection:\n\nIs empty: `p.appointments IS EMPTY`\rThis filters out all Patients that don’t have any associated Appointment entities. You can negate the operator (IS NOT EMPTY) to instead only select Patients that do have associated Appointments.\n\nSize: `size(p.appointments) > 2`\rThis filters out all Patients that have more than two Appointment entities associated with them.\n\nMember of: `:myAppointment member of p.appointment`\rThis filters out all Patients who aren’t associated with a given appointment.\n\n### Distinct query results\nThis will filter out duplicate entities from a set.\n```sql\nSELECT DISTINCT p.lastName FROM Patient p\n```\n\nYou can use any number of operators in conjunction with each other. Below is an example of patients whose first names contain “et”, last name is not null, and have more than 10 appointments.\n```sql\nSELECT p FROM Patient p WHERE p.firstName like ‘%et%’ and p.lastName IS NOT NULL and size(p.appointments) >= 10\n```\n### Scalar values\nScalar value projections are similar to the projections you know from SQL. Instead of selecting specific columns from a database, you’ll select entity attributes or the return value of a function call with your query. \n```sql\nSELECT p.firstName, p.lastName FROM Patient p\n```\n### Constructor references\nConstructor references are a good projection for read-only use cases. They’re more comfortable to use than scalar value projections and avoid the overhead of managed entities.\n\nJPQL allows you to define a constructor call in the SELECT clause. You can see an example of it in the following code snippet. You just need to provide the fully qualified class name and specify the constructor parameters of an existing constructor. Similar to the entity projection, Hibernate generates a SQL query which returns the required database columns and uses the constructor reference to instantiate a new object for each record in the result set.\n```sql\nSELECT new org.thoughts.on.java.model.PatientValue(p.id, p.firstName, p.lastName) FROM Patient p\n```\n\nJPQL syntax is also detailed in the official [Java EE specification.](https://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html)\n",
              "instructor_notes": ""
            },
            {
              "id": 900008,
              "key": "cd2ec445-3e6a-4a33-8c5e-69884d0e1a4c",
              "title": "Using Queries in JPA",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Creating a Query in JPA\n```sql\nQuery q = em.createQuery(‘SELECT Order o from Order’);\n```",
              "instructor_notes": ""
            },
            {
              "id": 900005,
              "key": "c489f2fc-62ce-4b96-a01c-7211e0950373",
              "title": "Relationships in JPQL",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Relationships in JPQL\n### Inner Join\nInner joins are similar to the corresponding feature in SQL. \n```\nSELECT p, a FROM Patient p JOIN p.appoinments a\n```\nIn SQL, the join can be across any table as long as there is a column that they can be joined. JPQL restricts JOIN to only related entities. For the above query to work, Order must have a defined relationship like one-to-many with OrderItem.\n### Left Outer Join\nLEFT JOINs work as they do in SQL as well. If you want to include the patients without appointments, you have to use a LEFT JOIN, like in the following code snippet.\n```sql\nSELECT p, a FROM Patient p LEFT JOIN p.appointments a\n```\n\nOther SQL join types, like Right Join, are also supported by JPQL. \n\n#### Path expressions or implicit joins\nPath expressions create implicit joins and are one of the strengths of using an entity model. You can use the ‘.’ operator to include to related entities.\n```sql\nSELECT a FROM Appointment a WHERE a.doctor.name LIKE ‘%es%\n```\n\nAs you can see, I use the ‘.’ operator to navigate via the doctor attribute of the Appointment entity a to the related Doctor entities. That creates an implicit join between the Appointment and Doctor entity. This is as if we used an additional join statement in a SQL query.\n",
              "instructor_notes": ""
            },
            {
              "id": 899999,
              "key": "5bad988c-5554-4433-ac41-56578ee044e6",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "5bad988c-5554-4433-ac41-56578ee044e6",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Queries are executed and no errors in the log."
              ],
              "positive_feedback": "Well done. You now know how to write JPQL queries using EntityManager.",
              "video_feedback": null,
              "description": "Add queries to your code from the previous exercise. Test to see that your queries return the correct results."
            }
          ]
        },
        {
          "id": 900017,
          "key": "1b4483ac-2587-47b2-bd68-7f2e0fbef0b2",
          "title": "Spring Data JPA",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1b4483ac-2587-47b2-bd68-7f2e0fbef0b2",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900012,
              "key": "9baa67cd-2ce0-42a8-8057-44f22ba2bee6",
              "title": "Javand305-C03-L02-A06-Spring-Data-Jpa 1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Pn_QkiNj5SA",
                "china_cdn_id": "Pn_QkiNj5SA.mp4"
              }
            },
            {
              "id": 966224,
              "key": "d9b67565-32ba-44e0-bd24-6f9e60c9cb40",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Repositories\nThere are 3 important repository interfaces when using Spring Data JPA:  \n- [CrudRepository](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html)\n- [PagingAndSortingRepository](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html)\n- [JpaRepository](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html)\n\n__CrudRepository__ interface introduces create, read, update and delete operations. \n \nThe __PagingAndSortingRepository__ extends the __CrudRepository__ and adds __findAll__ methods that let you to sort results and retrieve them in a paginated way.\n\nThe __JpaRepository__ adds JPA-specific methods, like __flush()__ to trigger a flush on the persistence context or __findAll(Example<S\\> example)__ to find entities by example, to the __PagingAndSortingRepository__. \n\nFurther explanations about Spring Data repositories and their capabilities can be found in the official [Spring Data JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories) documentation. ",
              "instructor_notes": ""
            },
            {
              "id": 900006,
              "key": "739a4c04-c545-4ee8-9103-1885c31bde77",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "739a4c04-c545-4ee8-9103-1885c31bde77",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Repository for the entity is defined.",
                "Repository has the respective query methods."
              ],
              "positive_feedback": "Well done! You have used Spring Data JPA to manage entities.",
              "video_feedback": null,
              "description": "Students will rewrite the previous exercise to see how Spring Data JPA simplifies data access layer even further."
            }
          ]
        },
        {
          "id": 900015,
          "key": "0d925dbf-c24c-40aa-a102-a11136afac98",
          "title": "DB Testing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "0d925dbf-c24c-40aa-a102-a11136afac98",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900001,
              "key": "42d13f30-e293-4e4e-97f9-e712b3cb0831",
              "title": "JavaND#305 C03 L02 A05 DB Testing",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ftmpdM-EdeY",
                "china_cdn_id": "ftmpdM-EdeY.mp4"
              }
            },
            {
              "id": 960257,
              "key": "11892662-cf5f-4537-9d5f-38ce2bda7222",
              "title": "Spring Data JPA Tests",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Spring Data JPA Tests\nTo test Spring Data JPA repositories, or any other JPA-related components for that matter, Spring Boot provides the [@DataJpaTest](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/orm/jpa/DataJpaTest.html) annotation. We can just add it to our JUnit tests and it will set up a Spring application context.\n\nLet’s see how to write a JUnit 4 test for the `OrderRepository`,\n\n```java\n@RunWith(SpringRunner.class)\n@DataJpaTest\npublic class OrderRepositoryTest {\n\n  @Autowired private DataSource dataSource;\n  @Autowired private JdbcTemplate jdbcTemplate;\n  @Autowired private EntityManager entityManager;\n  @Autowired private TestEntityManager testEntityManager;\n  @Autowired private OrderRepository orderRepository;\n\n  @Test\n  public void injectedComponentsAreNotNull(){\n    assertThat(dataSource).isNotNull();\n    assertThat(jdbcTemplate).isNotNull();\n    assertThat(entityManager).isNotNull();\n    assertThat(testEntityManager).isNotNull();\n    assertThat(orderRepository).isNotNull();\n  }\n\n  @Test\n  public void testFindByCustomerName(){\n     // create Order\n     Order order = new Order();\n     // set fields\n    order.setCustomerName(“John Doe”);\n    …\n\n    entityManager.persist(order);\n    \n    Order actual = orderRepository.findByCustomerName(“John Doe”)\n    assertThat(actual).isNotNull();\n    assertEquals(order.getId(), actual.getId());\n  }\n}\n\n```\n\nThe so created application context will not contain the whole context needed for our Spring Boot application, but instead only a “slice” of it containing the components needed to initialize any JPA-related components like our Spring Data repository.\n\nWe can, for instance, inject a *DataSource*, *JdbcTemplate*, *EntityManager* or a specialized wrapper *TestEntityManager* with helper methods for testing, into our test class if we need them. Also, we can inject any of the Spring Data repositories from our application. All of the above components will be automatically configured to point to an embedded, in-memory database instead of the “real” database we might have configured in *application.properties* files.\n\nNote that by default the application context containing all these components, including the in-memory database, is shared between all test methods within all @DataJpaTest-annotated test classes.\nThis is why, by default, **each test method runs in its own transaction, which is rolled back after the method has executed**. This way, the database state stays pristine between tests and the tests stay independent of each other.\n\n##### Resources\n- [SpringRunner](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/junit4/SpringRunner.html)\n- [RunWith](http://junit.sourceforge.net/javadoc/org/junit/runner/RunWith.html)",
              "instructor_notes": ""
            },
            {
              "id": 900004,
              "key": "e114a07c-da76-4303-8d31-bdf522104155",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "e114a07c-da76-4303-8d31-bdf522104155",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Tests written pass without failures.",
                "Tests run against an in-memory H2 instance."
              ],
              "positive_feedback": "Nice job on writing tests.",
              "video_feedback": null,
              "description": "Using your code from the previous exercises, write tests for some of the operations done in the previous exercises."
            }
          ]
        },
        {
          "id": 900014,
          "key": "3e2818be-5980-459c-ae12-89b8193e72ce",
          "title": "Recap",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3e2818be-5980-459c-ae12-89b8193e72ce",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900003,
              "key": "9c438c21-daab-4d92-b856-38ae6757159f",
              "title": "JavaND#305 C03 L02 A06 Recap",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "7EQlI3HAhDk",
                "china_cdn_id": "7EQlI3HAhDk.mp4"
              }
            }
          ]
        }
      ]
    }
  }
}