{
  "data": {
    "lesson": {
      "id": 900292,
      "key": "4766fa84-e182-45d4-b411-fe59b3b02c4c",
      "title": "NoSQL and MongoDB",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Learn the advantages of NoSQL databases and the basics of MongoDB, a document database.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/4766fa84-e182-45d4-b411-fe59b3b02c4c/900292/1564509586966/NoSQL+and+MongoDB+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/4766fa84-e182-45d4-b411-fe59b3b02c4c/900292/1564509584670/NoSQL+and+MongoDB+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 900287,
          "key": "5e07b8a3-aa12-43b6-9fc3-429039fd5cae",
          "title": "NoSQL Databases",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5e07b8a3-aa12-43b6-9fc3-429039fd5cae",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900278,
              "key": "5999e44c-e46a-48a0-85d1-9f4c91ba43f3",
              "title": "JavaND#305 C03 L03 A01 NoSQL Databases",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Ux4IchWaF98",
                "china_cdn_id": "Ux4IchWaF98.mp4"
              }
            },
            {
              "id": 900274,
              "key": "da295f0a-d484-4752-bc41-2f1726aec8f0",
              "title": "Introduction Recap",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n**Relational databases** use structured query language (SQL) for accessing, creating, and changing data. SQL is a versatile and widely used query language, and it is useful for complex queries. While SQL is useful in many situations, its restrictive nature isn’t ideal in every situation. SQL databases are table-based and require predefined schemas to determine the structure of your data before you work with it. All of your data must all follow the same, predefined structure. This can make it difficult to make changes after the schema has been designed and put into use.\n\n**NoSQL databases** have dynamic schemas which use unstructured data. This means that data is not restricted to being stored in a table; it can use columns, documents, graphs, or organized using key-value pairs.\n\nNoSQL databases differs from SQL databases in the following ways:\n\n- NoSQL databases are self-describing and do not require a schema.\n- NoSQL databases do not enforce relations between tables, and not all of your data has to have the same, predefined structure.\n- NoSQL databases can add fields after a database has been created.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 900288,
          "key": "b190c252-6922-4d83-9871-26e2e36bad74",
          "title": "MongoDB",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b190c252-6922-4d83-9871-26e2e36bad74",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900273,
              "key": "7de9b55c-3e63-4feb-befd-4721eacba77b",
              "title": "JavaND#305 C03 L03 A02 Mongo DB",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "5YPoe0LrL_U",
                "china_cdn_id": "5YPoe0LrL_U.mp4"
              }
            },
            {
              "id": 900280,
              "key": "8378c023-6297-4c9c-aa1e-81820b0d7bc8",
              "title": "Summary",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## MongoDB\n\nSimilar to MySQL, MongoDB also follows the client server model.\n\n> The name MongoDB comes from the word, humongous. It is built to store lots and lots of data.\n\n\nDatabases are made up of sets of collections. Documents are organized into collections. So, what are documents?\n\n#### Documents\n[In MongoDB, data is organized into documents](https://docs.mongodb.com/manual/core/document/). A document is a collection of key and value pairs (also referred to as *field-and-value* pairs). \n\n```json\n{\n   field1: value1,\n   field2: value2,\n   field3: value3,\n   ...\n   fieldN: valueN \n}\n```\n\nThe values stored in a document can be any [BSON data type](https://docs.mongodb.com/manual/reference/bson-types/). The below example shows, in order, an **ObjectId**, an **embedded document** which contains the fields `first` and `last`, two **Date**s, and, finally, an **array of strings**. As you can see from the below example, there are many types of values we can store in a document, included other documents!\n\n```json\nvar myFirstDoc = {\n               _id: ObjectId(\"4904803df364948bd2f45896\"),\n               name: { first: \"Ada\", last: \"Lovelace\" },\n               birth: new Date(‘Dec 10, 1815’),\n               death: new Date(‘Nov 27, 1852),\n               known: [ \"Mathematics\", \"Computing\" ]\n            }\n```\n\nIn MongoDB, the `_id` field is particularly important, because it acts as a primary key. Each document must have a unique `_id`.  If an inserted document omits the _id field, the MongoDB driver automatically generates an ObjectId for the _id field.\n\nAs mentioned previously, you can use any BSON data type in a collection. From the MongoDB documentation, BSON is: “[a serialization format used to store documents and make remote procedure calls in MongoDB. “BSON” is a portmanteau of the words “binary” and “JSON”. Think of BSON as a binary representation of JSON (JavaScript Object Notation) documents.](https://docs.mongodb.com/manual/core/document/)”\n\nSome advantages of using documents are:  \n\n- Documents and value types correspond to commonly used data types in many programming languages.\n- The ability to embed documents and arrays into other documents reduces the need for expensive joins.\n\n##### Additional Resources:  \n\n- [MongoDB](https://www.mongodb.com/what-is-mongodb)\n- [JSON Spec](https://www.json.org/)\n- [BSON types](https://docs.mongodb.com/manual/reference/bson-types/)",
              "instructor_notes": ""
            },
            {
              "id": 900286,
              "key": "127f16da-3131-483f-9bb3-0222990f0231",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "127f16da-3131-483f-9bb3-0222990f0231",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Start the MongoDB server using the instructions provided in the above links.",
                "Connect to the server using [mongo](https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo) shell.",
                "Create a user with read/write and admin permission. \n\n*(We will use this user to connect to the database moving forward.)*\n\n`db.createUser({\"user\": \"course3\", \"pwd\": \"course3\", \"roles\": [\"readWrite\", \"dbAdmin\"]});`",
                "Run the command `use jdnd-c3` that creates a database of that name."
              ],
              "positive_feedback": "Congratulations! You have a working installation of MongoDB server on your local workstation.",
              "video_feedback": null,
              "description": "#### MongoDB Installation\n- [Installing MongoDB Server on Windows](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)\n- [Installing MongoDB Server on MacOS](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)"
            }
          ]
        },
        {
          "id": 900289,
          "key": "8c1dc3aa-17fa-4bf4-9277-9149054ae4a3",
          "title": "Working with documents",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "8c1dc3aa-17fa-4bf4-9277-9149054ae4a3",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900277,
              "key": "48032e65-2493-4661-b81c-0a2697ba1db3",
              "title": "JavaND#305 C03 L03 A03 Create Documents",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "GmiGhare8u0",
                "china_cdn_id": "GmiGhare8u0.mp4"
              }
            },
            {
              "id": 900272,
              "key": "c2cfb2b5-2b4e-40ee-bc00-8f5656c8f213",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "c2cfb2b5-2b4e-40ee-bc00-8f5656c8f213",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Create a collection named **members**.",
                "Insert a _member_ document with no *_id* field but include all the other fields. Run `db.members.find()` to check if the *_id* is generated.",
                "Insert a _member_ document with all the fields including *_id*. Run `db.members.find()` and check *_id* is NOT overwritten by the database.",
                "Insert 5 _member_ documents using one `insert`.",
                "Update the name of the field `gender` to `sex` in all the inserted documents.",
                "Delete a document using its _id.",
                "Delete just **one** document whose `sex` is `male`.  **Tip:** This requires you to look through the [MongoDB documentation](https://docs.mongodb.com/) to find the right command."
              ],
              "positive_feedback": "Well done! You now know how to create,update and delete documents in a collection.",
              "video_feedback": null,
              "description": "##### Environment Setup\n- MongoDB server is started.\n- Use mongo shell to connect to your local MongoDB server.\n- Select the database `jdnd-c3`.\n\n##### Document Structure\nThe _member_ document represents the members of a health club.\n\n```json\n{\n\t\"_id\": “cjenkins”,\n\t\"first_name\": \"Carl\",\n\t\"last_name\": \"Jenkins\",\n\t\"gender\": \"male\",\n\t\"age\": 23,\n\t\"address\": {\n\t\t\"street\": \"123 Main Street\",\n\t\t\"city\": \"Oakland\",\n\t\t\"state\": \"CA\"\n\t},\n\t\"interests\": [\"pilates\",\"swim\",\"crossfit\"],\n\t\"balance\": 125.20\n}\n```"
            },
            {
              "id": 900282,
              "key": "0b161c20-a507-452d-ba7a-eaf025598c0a",
              "title": "JavaND#305 C03 L03 A04 Querying Documents",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "KJfLKSVSKOs",
                "china_cdn_id": "KJfLKSVSKOs.mp4"
              }
            },
            {
              "id": 900285,
              "key": "a915b25d-1ada-45b2-bf51-a58876e28202",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a915b25d-1ada-45b2-bf51-a58876e28202",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Find all members whose `last_name` is `Khan`. There should be one document in the results.",
                "Find all members whose `last_name` is `Doe` and `gender` is `female`. There should be one document in the results.",
                "Find all members who are interested in `golf`. There should be 2 documents in the results.",
                "Find all members who live in `MN`. There should be 2 documents in the results.",
                "Count the number of members who are `male`. Result: 3",
                "Find the first _member_ who is a `female` sorted by their `first_name`. Result: Member’s `first_name` is `Jane`."
              ],
              "positive_feedback": "Well done! You used the various query methods in MongoDB.",
              "video_feedback": null,
              "description": "##### Environment Setup\n- Use mongo shell to connect to your local MongoDB server.\n- Select the database `jdnd-c3`.\n- Run `db.members.remove({})` to remove all documents in the collection.\n- Insert the seed data given below.\n\n**Seed Data**\n```\ndb.members.insert([{\n  first_name: \"Jane\",\n  last_name: \"Doe\",\n  age: 45,\n  gender: \"female\",\n  interests: [\"pilates\",\"swim\",\"crossfit\"],\n  balance: 125.20,\n  address: {\n      street: \"123 Main St\",\n      city: \"Birmingham\",\n      state: \"AL\"\n  }\n},\n{\n  first_name: \"John\",\n  last_name: \"Doe\",\n  age: 47,\n  gender: \"male\",\n  interests: [\"pilates\",\"swim\"],\n  balance: 56.25,\n  address: {\n      street: \"123 First St\",\n      city: \"Minneapolis\",\n      state: \"MN\"\n  }\n},\n{\n  first_name: \"Lakshmi\",\n  last_name: \"Natarajan\",\n  age: 29,\n  gender: \"female\",\n  interests: [\"swim\", \"tennis\"],\n  balance: 556.39,\n  address: {\n      street: \"149 Main St\",\n      city: \"Birmingham\",\n      state: \"AL\"\n  }\n},\n{\n  first_name: \"Eduardo\",\n  last_name: \"Lopez\",\n  age: 32,\n  gender: \"male\",\n  interests: [\"swim\", \"tennis\", \"golf\"],\n  balance: 1034.23,\n  address: {\n      street: \"298 Second St\",\n      city: \"Birmingham\",\n      state: \"AL\"\n  }\n},\n{\n  first_name: \"Sana\",\n  last_name: \"Khan\",\n  age: 53,\n  gender: \"female\",\n  interests: [\"golf\"],\n  balance: 500,\n  address: {\n      street: \"649 First St\",\n      city: \"Minneapolis\",\n      state: \"MN\"\n  }\n},\n{\n  first_name: \"Rahul\",\n  last_name: \"Mani\",\n  age: 18,\n  gender: \"male\",\n  interests: [\"swim\"],\n  balance: 250,  \n  address: {\n      street: \"41 Second Ave\",\n      city: \"Indianapolis\",\n      state: \"IN\"\n  }\n}\n]);\n```"
            }
          ]
        },
        {
          "id": 900291,
          "key": "017e5571-5ef5-4361-8b87-c6836697e03b",
          "title": "Data Modeling",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "017e5571-5ef5-4361-8b87-c6836697e03b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900281,
              "key": "50ba286e-048b-4da8-9101-5004edc74d1a",
              "title": "JavaND#305 C03 L03 A05 Data Modeling",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ZCFENvM9tuo",
                "china_cdn_id": "ZCFENvM9tuo.mp4"
              }
            },
            {
              "id": 900279,
              "key": "0a072bda-f08d-4ada-a3d2-f377867851e3",
              "title": "Quiz",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "0a072bda-f08d-4ada-a3d2-f377867851e3",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Check all that are true for MongoDB data modeling.",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "Embedded data model is preferred for “contains” relationship between entities.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "Embedded data model can support many-to-many relationships.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "A write operation is atomic for a single document including the embedded documents.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk4",
                    "text": "For document references, the application needs to maintain the integrity of the relationship.",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 900283,
              "key": "cd858bdf-e3b6-4712-8727-818de86147e2",
              "title": "Patterns",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### One-to-One with Embedded Documents\n\nMongoDB supports having another document as a value of key. One way of achieving a one-to-one relationship between documents is by embedding the related document in the parent document. Consider the example of a patient document. A patient usually has an associated address for communication.  \nIn a normalized data model, the address document would contain a reference to the address document.\n\n```json\n{\n   _id: \"lakshmi\",\n   name: \"Lakshmi Natarajan\"\n}\n\n{\n   patient_id: \"lakshmi\",\n   street: \"149 Main St\",\n   city: \"Birmingham\",\n   state: \"AL\"\n}\n```\n\nIn the above example, if your application typically needs the address along with other patient information, it needs to send an additional query to read the related address. It becomes more of a problem if a patient has multiple addresses. For this use-case, embedding works well since the patient information along with the address can be read in one query, \n\n```json\n{\n   _id: \"lakshmi\",\n   name: \"Lakshmi Natarajan\",\n   address: {\n                 street: \"149 Main St\",\n                 city: \"Birmingham\",\n                 state: \"AL\"\n           }\n}\n```\n\n\n#### One-to-Many with Embedded Documents\nJust like One-to-One, One-to-Many relationships can be achieved by embedding multiple documents. \n\nThe address documents include a reference to the patient documents.\n\n```json\n{\n   _id: \"lakshmi\",\n   name: \"Lakshmi Natarajan\"\n}\n\n{\n   patient_id: \"lakshmi\",\n   street: \"149 Main St\",\n   city: \"Birmingham\",\n   state: \"AL\"\n}\n\n{\n      patient_id: \"lakshmi\",\n      street: \"298 Second St\",\n      city: \"Birmingham\",\n      state: \"AL\"\n}\n```\n\n \nWith Embedding:\n\n```json\n{\n   _id: \"lakshmi\",\n   name: \"Lakshmi Natarajan\"\n   addresses: [{\n   street: \"149 Main St\",\n   city: \"Birmingham\",\n   state: \"AL\"\n},\n{\n      street: \"298 Second St\",\n      city: \"Birmingham\",\n      state: \"AL\"\n}]\n }\n```\n\n#### One-to-Many with Document References\nEven though embedding is convenient and seems to make life easier for developers, it may not be optimal for all use-cases. For instance, there is a limit to how large a document can be. There are other scenarios where embedding does not make sense, like when repetition needs to be avoided. \n\nIn the below example, embedding the artist document inside the movie document leads to repetition of the artist data:\n\n```json\n{\n\t\"_id\": \"12345\"\n\t\"title\": \"Seven\"\n\t\"cast\": [{\n\t\t\"name\": \"Brad Pitt\",\n\t\t\"gender\": \"male\",\n\t\t\"age\": 51\n\t},\n\t{\n\t\t\"name\": \"Morgan Freeman\",\n\t\t\"gender\": \"male\",\n\t\t\"age\": 70\n\t},\n\t{\n\t\t\"name\": \"Gwyneth Paltrow\",\n\t\t\"gender\": \"female\",\n\t\t\"age\": 46\n\t}]\n}\n\n{\n\t\"_id\": \"12346\"\n\t\"title\": \"Fight Club\"\n\t\"cast\": [{\n\t\t\"name\": \"Brad Pitt\",\n\t\t\"gender\": \"male\",\n\t\t\"age\": 51\n\t}]\n}\n```\n\nThe repetition makes it harder to update the details of the artist document.  In order to update the _age_ field of an actor, all the movie documents containing the artist document need to be updated.\n\nAs you might have guessed, document references work well here. \n\n**Artist Collection**\n```json\n{\n\t\t\"_id\": \"abc123\",\n\t\t\"name\": \"Brad Pitt\",\n\t\t\"gender\": \"male\",\n\t\t\"age\": 51\n\t}\n\t\n\t{\n\t\t\"_id\": \"abc124\",\n\t\t\"name\": \"Morgan Freeman\",\n\t\t\"gender\": \"male\",\n\t\t\"age\": 70\n\t}\n\n\t{\n\t\t\"_id\": \"abc125\",\n\t\t\"name\": \"Gwyneth Paltrow\",\n\t\t\"gender\": \"female\",\n\t\t\"age\": 46\n\t}\n```\n**Movie Collection**\n```json\n{\n\t\"_id\": \"12345\"\n\t\"title\": \"Seven\"\n\t\"cast\": [\"abc123\", \"abc124\", \"abc125\"]\n}\n{\n\t\"_id\": \"12346\"\n\t\"title\": \"Fight Club\"\n\t\"cast\": [\"abc123\"]\n}\n```\n\nThe number of artists in a movie doesn’t grow, but an artist can keep acting in more movies. So in this case, storing the reference in the movie makes sense.",
              "instructor_notes": ""
            },
            {
              "id": 900284,
              "key": "e56d4d1e-ef5e-4196-a3cb-ac7704a2d876",
              "title": "Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "e56d4d1e-ef5e-4196-a3cb-ac7704a2d876",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is the advantage of using document references in data modeling?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "Document references can be loaded along with the referring document in a single call to the database",
                    "is_correct": false
                  },
                  {
                    "id": "rbk2",
                    "text": "MongoDB guarantees atomic writes when updating documents and the references it holds.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "Document references are best suited for a “contains” relationship.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk4",
                    "text": "Document references are useful when duplication of data needs to be avoided.",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 900275,
              "key": "80494f7e-01e2-49db-a002-f586dc1df155",
              "title": "Quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "80494f7e-01e2-49db-a002-f586dc1df155",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "When to embed documents within documents?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "In one-to-many relationships, where the “many” documents are viewed in the context of the “one” or documents.",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "Embedding documents reduces duplication of data.",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "Embedding documents increases the number of trips to the database.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 900276,
              "key": "68351237-c74f-49d5-8134-2b24f77dc531",
              "title": "Exercise",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "68351237-c74f-49d5-8134-2b24f77dc531",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Model these entities so a blog post can be read in one call to the MongoDB server."
              ],
              "positive_feedback": "Nice. You dabbled in data modeling. Data modeling takes practice, think of some other scenarios and write down how you would model them.",
              "video_feedback": null,
              "description": "Use MongoDB to store the data for a blog. These are the primary entities in a blog:\n\n1. Post - The actual blog post which has a title, text and an author.\n2. Comment - A comment written by a visitor for a particular post. A comment has the name of the visitor and text of the comment.\n3. Author - A person who writes posts. Author has first_name, last_name and email."
            },
            {
              "id": 960256,
              "key": "40cbec94-d373-4d42-89c3-631a6c9ca1cb",
              "title": "Data Modeling Intro",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Data Modeling: \n\nWhile designing documents in MongoDB, One of the key considerations for the structure of your documents is the decision to embed or to use references.\n\n#### Embedded Model:\n\nMongoDB allows embedding one document in another. you to embed related data in the same document. Consider the patient record\n\nIn general, use embedded data models when:\n\n- One-to-one or one-to-many relationships need to be represented. You have “contains” relationships between entities. For example, when a person contains an address.\n```json\n  “name”: “Jane Doe”,\n    “address”: [\n        {\n            “line1”: “123 Main St”,\n            “city”: “Birmingham”,\n            “state”: “AL”,\n            “zip”: 40881\n        }\n```\n\n- You have one-to-many relationships between entities. In these relationships the “many” or child documents always appear with or are viewed in the context of the “one” or parent documents. In the patient record document, a patient can have many visits to the clinic. The visit document has no meaning when its not associated with a patient. Therefore, it is embedded with the patient document.\n```json\n    “first_name”: “John”,\n    “last_name”: “Smith”,\n    “visits”: [\n        {\n            “data”: “2019-05-06”,\n            “physician”: “Robert Mendoza”,\n            “reason”: “Fever”\n        },\n        {\n            “data”: “2019-02-01”,\n            “physician”: “Manny Armann”,\n            “reason”: “Cough”\n         }\n```\n\nEmbedded models allow for better read performance since all the related data can be read in one go.\n\n#### Reference Model:\n\nReferences can be used to describe relationships between documents.\n\nIn general, use references:\n\n- If duplication needs to be avoided.when embedding would result in duplication of data but would not provide sufficient read performance advantages to outweigh the implications of the duplication.\n\n- To represent more complex many-to-many relationships.\n\nReferences provide more flexibility than embedding. However, applications must issue follow-up queries to resolve the references. In other words, normalized data models can require more round trips to the server.\n\n#### Operational Factors:\n\nEmbedded models support atomicity since MongoDB guarantees atomic operations at the document level. If atomicity is important for the application, the choice is clear. However there are many scenarios where references could be useful as well. A caveat of references is that the application needs to maintain them with no support from the database. Embedded data models make it possible to update related data in a single atomic write operation. In MongoDB, a write operation is atomic on the level of a single document, even if the operation modifies multiple embedded documents within a single document.\n\nAs soon as you start introducing references, it is up to the application to maintain the integrity of the documents.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 900326,
          "key": "94c1875c-66ce-406a-a607-8791f2bb7e97",
          "title": "Recap",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "94c1875c-66ce-406a-a607-8791f2bb7e97",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900290,
              "key": "2f7fa3df-18a9-42b9-9b45-3ec39eeba708",
              "title": "JavaND#305 C03 L03 A05 Recap",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "V5Q3IeuSxFs",
                "china_cdn_id": "V5Q3IeuSxFs.mp4"
              }
            }
          ]
        }
      ]
    }
  }
}